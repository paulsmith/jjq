JJQ(1)                      General Commands Manual                      JJQ(1)

NAME
       jjq - local merge queue for jj

SYNOPSIS
       jjq init [--trunk bookmark] [--check command]
       jjq push revset
       jjq run [--all]
       jjq check [--rev revset] [-v]
       jjq status [id] [--json] [--resolve change_id]
       jjq delete id
       jjq clean
       jjq doctor
       jjq config [key [value]]

DESCRIPTION
       jjq is a local merge queue for jj(1) (Jujutsu VCS).  It queues revisions
       for merging to a trunk bookmark, processes them in FIFO order, and gates
       each merge on a configurable check command.  This prevents the “works on
       my  branch” problem where changes pass checks individually but fail when
       combined with concurrent work.

       jjq stores all state inside the jj repository  using  bookmarks  and  an
       isolated metadata branch.  No external database or service is required.

COMMANDS
   init [--trunk bookmark] [--check command]
       Initialize  jjq  in the current repository.  Sets up the metadata branch
       and configures the trunk bookmark and check command.

       With --trunk and --check flags, runs non-interactively.  Without  flags,
       prompts  for  each  value.   The trunk bookmark defaults to main if that
       bookmark exists, or master as a fallback.

       If stdin is not a terminal and required flags are missing, exits with an
       error.

       Refuses to run if jjq is already initialized.  Use jjq config to  change
       settings after initialization.

       After configuration, runs jjq doctor to validate the setup.

   push revset
       Queue  a  revision for merging to trunk.  The revset must resolve to ex‐
       actly one revision.

       Before queuing, jjq creates a temporary merge commit between  the  trunk
       and  the candidate to check for textual conflicts.  If conflicts are de‐
       tected, the push is rejected with exit code 1.

       Push is idempotent for the same change ID:  if  the  change  is  already
       queued  or  failed,  the  stale  entry  is  cleared  and the revision is
       re-queued.  However, if the same change ID is already queued at  a  dif‐
       ferent  commit ID (i.e., the revision has been amended), the push is re‐
       jected with exit code 10.

              jjq push @              # queue the working copy
              jjq push feat-xyz@      # queue a workspace's working copy
              jjq push abc123         # queue by change ID

   run [--all]
       Process the next queued item.  Creates a temporary jj workspace with two
       parents (trunk and candidate), then runs the  configured  check  command
       inside it.

       On success, the trunk bookmark advances to the merge commit and the tem‐
       porary workspace is cleaned up.

       On  failure  (conflicts or check command failure), the item moves to the
       failed list.  The temporary workspace is preserved for debugging.

       If the trunk bookmark moves during processing (e.g., another runner  ad‐
       vanced it), the run aborts and instructs the user to retry.

       With  --all,  processes  items  in a loop until the queue is empty or an
       item fails.  Reports the count of successes and failures.

       Returns 0 if at least one item was processed successfully (or the  queue
       was empty).  Returns 1 if any item failed.

   check [--rev revset] [-v]
       Run the configured check command against a revision in a temporary work‐
       space without any queue processing.  Useful for verifying that the check
       command works before queuing items.

       Defaults to the current working copy (@) if --rev is not specified.

       With  -v (--verbose), prints the workspace path, shell, and all environ‐
       ment variables before running the check command.  Useful for  diagnosing
       path or environment issues.

       The  temporary  workspace  is  always cleaned up, regardless of outcome.
       Exits 0 if the check passes; 1 if it fails.

   status [id] [--json] [--resolve change_id]
       Display the current queue state: queued items (ascending by sequence ID)
       and recent failures (descending, up to max_failures).  Each entry  shows
       its sequence ID, change ID prefix, and first line of the commit descrip‐
       tion.

       Also  indicates  if  a run lock is currently held (another jjq run is in
       progress).

       With --json, outputs structured JSON with  running,  queue,  and  failed
       fields.   Queue  items  include  change_id,  commit_id, and description.
       Failed items include candidate_change_id, candidate_commit_id,  descrip‐
       tion  (original candidate message), trunk_commit_id, workspace_path, and
       failure_reason.

       With a positional id, displays a single item's detail view (from  either
       queue  or  failed).   With  --resolve, looks up an item by its candidate
       change ID.  id and --resolve are mutually exclusive.

   delete id
       Remove an item from the queue or the failed list  by  its  sequence  ID.
       The  sequence ID is the number shown in status output and push confirma‐
       tion messages.

   clean
       Remove jjq workspaces left behind by failed merges.   Lists  each  work‐
       space  removed.   Safe to run at any time — only removes jjq-owned work‐
       spaces, never user workspaces.

   doctor
       Validate that the jjq environment is correctly configured.   Checks  the
       trunk  bookmark, check command, lock state, and workspace preconditions.
       Each check is reported as ok, WARN, or FAIL.  When a check fails, a sug‐
       gested fix is shown.

       Exits 0 if no failures are found (warnings are tolerated).  Exits  1  if
       any check fails.

   config [key [value]]
       Get or set configuration.  With no arguments, displays all configuration
       values.   With  one argument, displays that key's value.  With two argu‐
       ments, sets the key to the given value.

       Valid keys:

       trunk_bookmark (default: “main”)
              The bookmark that jjq treats as the protected trunk.  All  merges
              target this bookmark.

       check_command (required)
              Shell  command to run in the merge workspace to validate a candi‐
              date.  Should run tests, lints, type checks,  or  whatever  gates
              your trunk.  Exit 0 means pass; non-zero means fail.

              Set during jjq init or configured afterward with jjq config.

       max_failures (default: 3)
              Number of recent failures shown by status.

EXIT CODES
       0      Success.

       1      Merge conflict or check command failure.

       3      Lock held.  Another jjq process is running.  Retry later.

       10     Usage  error.  Bad arguments, ambiguous revset, duplicate push of
              an amended revision, etc.

CONFIGURATION
       jjq stores configuration on an isolated metadata branch  (jjq/_/_)  par‐
       ented  to  the  repository root.  This branch never appears in normal jj
       log output and does not pollute user history.

       Always configure check_command before using jjq run.  The default  check
       command rejects everything.

LOCKING
       jjq  uses flock-based file locks in .jj/jjq-locks/ to coordinate concur‐
       rent access.  Locks are released automatically by the OS when the  hold‐
       ing process exits, so stale locks cannot occur.

       id     Protects sequence ID allocation (brief, during push).

       config Protects configuration reads and writes.

       run    Ensures only one jjq run processes the queue at a time.

DATA MODEL
       Queue  items  are  jj bookmarks named jjq/queue/NNNNNN where NNNNNN is a
       zero-padded sequence ID.  Failed items use jjq/failed/NNNNNN.  The meta‐
       data branch at jjq/_/_ stores the last allocated ID and  all  configura‐
       tion.

       Successful  merges  are  ordinary jj commits with two parents (trunk and
       candidate) and descriptions like “Success: merge N”.  Failed merges  are
       preserved  as conflicted commits with descriptions like “Failed: merge N
       (conflicts)”.

TYPICAL WORKFLOW
       Initialize a project:

              jjq init --trunk main --check "make test && make lint"

       Developer queues work:

              jjq push @

       Process the queue:

              jjq run          # one item
              jjq run --all    # drain the queue

       Handle a failure:

              jjq status                    # see what failed
              jj rebase -r <rev> -d main    # rebase onto current trunk
              ... resolve conflicts ...
              jjq push <rev>                # re-queue
              jjq run                       # retry

       Clean up:

              jjq clean

ENVIRONMENT
       jjq must be run from within a jj repository.  It invokes jj  as  a  sub‐
       process and expects it to be on PATH.

TIPS
       Configure jj log to hide jjq metadata bookmarks:

              jj config set --repo 'revset-aliases."trunk()"' \
                  'main | ancestors(main, 2)'

       The  check  command  runs  in  a temporary workspace that has the merged
       state of trunk + candidate.  Any command that works in a normal checkout
       works here.

       Push is cheap.  If you're unsure whether your  revision  will  conflict,
       just  push  it  — jjq checks for conflicts up front and rejects the push
       immediately.

       For parallel development with multiple  agents  or  developers,  use  jj
       workspaces.   Each workspace gets its own isolated working copy branched
       from trunk.  Push from each workspace independently and let jjq  serial‐
       ize the merges.

SEE ALSO
       jj(1)

AUTHORS
       Paul Smith

jjq                                2026-02-03                            JJQ(1)
