JJQ(1)                      General Commands Manual                     JJQ(1)

NAME
       jjq - local merge queue for jj

SYNOPSIS
       jjq init [--trunk bookmark] [--check command]
       jjq push revset
       jjq run [--all]
       jjq status
       jjq delete id
       jjq clean
       jjq doctor
       jjq config [key [value]]

DESCRIPTION
       jjq is a local merge queue for jj(1) (Jujutsu VCS).  It queues
       revisions for merging to a trunk bookmark, processes them in FIFO
       order, and gates each merge on a configurable check command.  This
       prevents the "works on my branch" problem where changes pass checks
       individually but fail when combined with concurrent work.

       jjq stores all state inside the jj repository using bookmarks and an
       isolated metadata branch.  No external database or service is required.

COMMANDS
   init [--trunk bookmark] [--check command]
       Initialize jjq in the current repository.  Sets up the metadata branch
       and configures the trunk bookmark and check command.

       With --trunk and --check flags, runs non-interactively.  Without flags,
       prompts for each value.  The trunk bookmark defaults to main if that
       bookmark exists, or master as a fallback.

       If stdin is not a terminal and required flags are missing, exits with
       an error.

       Refuses to run if jjq is already initialized.  Use jjq config to change
       settings after initialization.

       After configuration, runs jjq doctor to validate the setup.

   push revset
       Queue a revision for merging to trunk.  The revset must resolve to
       exactly one revision.

       Before queuing, jjq creates a temporary merge commit between the trunk
       and the candidate to check for textual conflicts.  If conflicts are
       detected, the push is rejected with exit code 1.

       Push is idempotent for the same change ID: if the change is already
       queued or failed, the stale entry is cleared and the revision is
       re-queued.  However, if the same change ID is already queued at a
       different commit ID (i.e., the revision has been amended), the push is
       rejected with exit code 10.

              jjq push @              # queue the working copy
              jjq push feat-xyz@      # queue a workspace's working copy
              jjq push abc123         # queue by change ID

   run [--all]
       Process the next queued item.  Creates a temporary jj workspace with
       two parents (trunk and candidate), then runs the configured check
       command inside it.

       On success, the trunk bookmark advances to the merge commit and the
       temporary workspace is cleaned up.

       On failure (conflicts or check command failure), the item moves to the
       failed list.  The temporary workspace is preserved for debugging.

       If the trunk bookmark moves during processing (e.g., another runner
       advanced it), the run aborts and instructs the user to retry.

       With --all, processes items in a loop until the queue is empty or an
       item fails.  Reports the count of successes and failures.

       Returns 0 if at least one item was processed successfully (or the queue
       was empty).  Returns 1 if any item failed.

   status
       Display the current queue state: queued items (ascending by sequence
       ID) and recent failures (descending, up to max_failures).  Each entry
       shows its sequence ID, change ID prefix, and first line of the commit
       description.

       Also indicates if a run lock is currently held (another jjq run is in
       progress).

   delete id
       Remove an item from the queue or the failed list by its sequence ID.
       The sequence ID is the number shown in status output and push
       confirmation messages.

   clean
       Remove jjq workspaces left behind by failed merges.  Lists each
       workspace removed.  Safe to run at any time -- only removes jjq-owned
       workspaces, never user workspaces.

   doctor
       Validate that the jjq environment is correctly configured.  Checks the
       trunk bookmark, check command, lock state, and workspace preconditions.
       Each check is reported as ok, WARN, or FAIL.  When a check fails, a
       suggested fix is shown.

       Exits 0 if no failures are found (warnings are tolerated).  Exits 1 if
       any check fails.

   config [key [value]]
       Get or set configuration.  With no arguments, displays all
       configuration values.  With one argument, displays that key's value.
       With two arguments, sets the key to the given value.

       Valid keys:

       trunk_bookmark (default: "main")
              The bookmark that jjq treats as the protected trunk.  All merges
              target this bookmark.

       check_command (required)
              Shell command to run in the merge workspace to validate a
              candidate.  Should run tests, lints, type checks, or whatever
              gates your trunk.  Exit 0 means pass; non-zero means fail.

              Set during jjq init or configured afterward with jjq config.

       max_failures (default: 3)
              Number of recent failures shown by status.

EXIT CODES
       0      Success.

       1      Merge conflict or check command failure.

       3      Lock held.  Another jjq process is running.  Retry later.

       10     Usage error.  Bad arguments, ambiguous revset, duplicate push of
              an amended revision, etc.

CONFIGURATION
       jjq stores configuration on an isolated metadata branch (jjq/_/_)
       parented to the repository root.  This branch never appears in normal
       jj log output and does not pollute user history.

       Always configure check_command before using jjq run.  The default check
       command rejects everything.

LOCKING
       jjq uses filesystem-based locks (atomic mkdir(2)) in .jj/jjq-locks/ to
       coordinate concurrent access:

       id     Protects sequence ID allocation (brief, during push).

       config Protects configuration reads and writes.

       run    Ensures only one jjq run processes the queue at a time.

       If a lock is stale (e.g., from a crashed process), delete the
       corresponding directory under .jj/jjq-locks/.

DATA MODEL
       Queue items are jj bookmarks named jjq/queue/NNNNNN where NNNNNN is a
       zero-padded sequence ID.  Failed items use jjq/failed/NNNNNN.  The
       metadata branch at jjq/_/_ stores the last allocated ID and all
       configuration.

       Successful merges are ordinary jj commits with two parents (trunk and
       candidate) and descriptions like "Success: merge N".  Failed merges are
       preserved as conflicted commits with descriptions like "Failed: merge N
       (conflicts)".

TYPICAL WORKFLOW
       Initialize a project:

              jjq init --trunk main --check "make test && make lint"

       Developer queues work:

              jjq push @

       Process the queue:

              jjq run          # one item
              jjq run --all    # drain the queue

       Handle a failure:

              jjq status                    # see what failed
              jj rebase -r <rev> -d main    # rebase onto current trunk
              ... resolve conflicts ...
              jjq push <rev>                # re-queue
              jjq run                       # retry

       Clean up:

              jjq clean

ENVIRONMENT
       jjq must be run from within a jj repository.  It invokes jj as a
       subprocess and expects it to be on PATH.

TIPS
       Configure jj log to hide jjq metadata bookmarks:

              jj config set --repo 'revset-aliases."trunk()"' \
                  'main | ancestors(main, 2)'

       The check command runs in a temporary workspace that has the merged
       state of trunk + candidate.  Any command that works in a normal
       checkout works here.

       Push is cheap.  If you're unsure whether your revision will conflict,
       just push it -- jjq checks for conflicts up front and rejects the push
       immediately.

       For parallel development with multiple agents or developers, use jj
       workspaces.  Each workspace gets its own isolated working copy branched
       from trunk.  Push from each workspace independently and let jjq
       serialize the merges.

SEE ALSO
       jj(1)

AUTHORS
       Paul Smith

jjq                               2026-02-03                            JJQ(1)
