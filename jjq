#!/bin/bash
set -euo pipefail

TRUNK_BOOKMARK=main
CHECK_COMMAND="make"

err() {
    echo "$*" >&2
}

preferr() {
    err "jjq: $*"
}

prefout() {
    echo "jjq: $*"
}

usage() {
    err "usage: jjq <cmd>"
    err ""
    err "commands:"
    err "   push <revset>           - push revision on merge queue"
    err "   run                     - try to merge next candidate on queue"
    err "   status                  - print the status of the queue"
    exit 1
}

[ $# -gt 0 ] || usage

cmd="$1"
shift

jjq_bookmark="jjq/_/_"

check_jjq() {
    if [ -z "$(jj bookmark list -r "bookmarks(exact:${jjq_bookmark})" -T name)" ]; then
        local change_id
        change_id="$(jj new --no-edit 'root()' 2>&1 | cut -f4 -d' ')"
        jj bookmark create -r "$change_id" "$jjq_bookmark"
        local d
        d=$(mktemp -d)
        # shellcheck disable=SC2064 # Intentional: capture $d now
        trap "rm -rf $d" EXIT
        jj workspace add -r "$jjq_bookmark" --name jjq "$d"
        pushd "$d"
        echo 0 > last_id
        jj desc -m "init jjq"
        jj squash
        popd
        jj workspace forget jjq

        if [ ! -f .jj/repo/config.toml ]; then
            if [ -z "${NON_INTERACTIVE-}" ]; then
                echo "Welcome to jjq"
                echo -n "Configure \`jj log\` to hide jjq metadata? "
                read -n1 -p '(y/N) ' -r answer
                echo
                if [[ $answer == [yY] ]]; then
                    cat > .jj/repo/config.toml <<-EOF
						[revsets]
						log = '~ ::${jjq_bookmark}'
					EOF
                fi
            fi
        fi
    fi
}

next_id() {
    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d now
    trap "rm -rf $d" EXIT
    local workspace_name="jjq$$"
    jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    pushd "$d" >/dev/null
    local curr
    curr="$(head -1 < last_id)"
    local id=$((curr + 1))
    echo "$id" > last_id
    jj desc -m "$curr -> $id" -m "pid: $$"
    jj bookmark set "$jjq_bookmark"
    jj workspace forget "$workspace_name"
    popd >/dev/null
    echo "$id"
}

cmd_push() {
    # Revset of the candidate revision the user is pushing on to the merge queue
    local revset="$1"
    shift

    if ! jj log -r "$revset" --no-graph -T'change_id.short()++"\n"' >/dev/null 2>&1; then
        preferr "revset '$revset' not found"
        exit 1
    fi

    check_jjq

    local id
    id="$(next_id)"
    local queue_bookmark
    queue_bookmark="$(printf "jjq/queue/%06d" "$id")"

    jj bookmark create -r "$revset" "$queue_bookmark"
    prefout "revision '$revset' queued at $id"
}

cmd_run() {
    local id
    id="$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' | grep -E '^jjq/queue/[0-9]{6}$' | cut -f3 -d'/' | sort -n | head -1)"
    if [ -z "$id" ]; then
        preferr "queue is empty"
        exit 0
    fi
    prefout "processing queue item $id"

    check_jjq

    local runner_workspace
    runner_workspace=$(mktemp -d)
    local run_name="jjq/run/$id"
    local lock="jjq/lock/run"

    # We use jj bookmarks to take out a global run lock, since only one runner
    # can process the queue at a time. This lets us avoid trying a cross-platform
    # file locking mechanism and keep it contained to jj.
    if ! jj bookmark create -r "$jjq_bookmark" "$lock" >/dev/null 2>&1; then
        # TODO: try to get the lock holder's PID from metadata somehow
        preferr "queue runner lock already held"
        exit 1
    fi

    trap "jj bookmark delete $lock >/dev/null 2>&1" EXIT

    # TODO: record this PID as metadata for the run somehow

    # Create a workspace to attempt the merge, with a new commit for the
    # merge-to-be with two parents: the trunk and the candidate revision
    jj workspace add -r "bookmarks(exact:$TRUNK_BOOKMARK)" -r "bookmarks(exact:jjq/queue/$id)" --name "$run_name" "$runner_workspace"
    pushd "$runner_workspace"

    # Check for conflicts in the merge-to-be commit
    if [ -n "$(jj log -r "${run_name}@" --no-graph -T'if(conflict, "has conflict(s)")')" ]; then
        jj bookmark delete "jjq/queue/$id"
        jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        jj desc -m "Failed: merge $id (conflicts)"
        preferr "merge $id has conflicts, marked as failed"
        preferr "workspace remains: $runner_workspace"
        popd
        exit 1
    fi

    jj desc -m "WIP: attempting merge $id"

    if ! $CHECK_COMMAND; then
        jj bookmark delete "jjq/queue/$id"
        jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        jj desc -m "Failed: merge $id (check)"
        preferr "merge $id check failed"
        preferr "workspace remains: $runner_workspace"
        popd
        exit 1
    else
        jj bookmark delete "jjq/queue/$id"
        jj desc -m "Success: merge $id"
        jj bookmark move "$TRUNK_BOOKMARK"
        popd
        jj workspace forget "$run_name"
        rm -rf "$runner_workspace"
    fi

    jj bookmark delete "$lock"
}

cmd_status() {
    local max_failures=3  # TODO: make configurable via jjq config

    # Check if jjq is initialized
    if [ -z "$(jj bookmark list -r "bookmarks(exact:${jjq_bookmark})" -T name 2>/dev/null)" ]; then
        prefout "jjq not initialized (push a revision on to the queue to initialize) "
        return
    fi

    local queue_items
    queue_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/queue/[0-9]{6}$' | sort || true)

    local failed_items
    failed_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/failed/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/failed/[0-9]{6}$' | sort -r | head -"$max_failures" || true)

    # Check for active run
    if jj bookmark list -r 'bookmarks(exact:"jjq/lock/run")' -T'name' 2>/dev/null | grep -q 'jjq/lock/run'; then
        prefout "Run in progress"
        echo
    fi

    if [ -z "$queue_items" ] && [ -z "$failed_items" ]; then
        prefout "queue is empty"
        return
    fi

    if [ -n "$queue_items" ]; then
        prefout "Queued:"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $((10#$id)): $info"
        done <<< "$queue_items"
    fi

    if [ -n "$failed_items" ]; then
        if [ -n "$queue_items" ]; then
            echo
        fi
        prefout "Failed (recent):"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $((10#$id)): $info"
        done <<< "$failed_items"
    fi
}

case "$cmd" in
    push) cmd_push "$@" ;;
    run) cmd_run "$@" ;;
    status) cmd_status "$@" ;;
    *) usage ;;
esac
