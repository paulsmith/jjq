#!/bin/bash
set -euo pipefail

TRUNK_BOOKMARK=main
CHECK_COMMAND="echo ok"

err() {
    echo "$*" >&2
}

preferr() {
    err "jjq: $*"
}

prefout() {
    echo "jjq: $*"
}

usage() {
    err "usage: jjq <cmd>"
    err ""
    err "commands:"
    err "   push <revset>           - push revision on merge queue"
    err "   run                     - try to merge next candidate on queue"
    exit 1
}

[ $# -gt 0 ] || usage

cmd="$1"
shift

jjq_bookmark="jjq/_/_"

check_jjq() {
    exec 1>>/tmp/jjq.log 2>/dev/null
    if [ -z "$(jj bookmark list -r "bookmarks(exact:${jjq_bookmark})" -T name)" ]; then
        local change_id="$(jj new --no-edit 'root()' 2>&1 | cut -f4 -d' ')"
        jj bookmark create -r "$change_id" "$jjq_bookmark"
        local d=$(mktemp -d)
        trap "rm -rf $d" EXIT
        jj workspace add -r "$jjq_bookmark" --name jjq "$d"
        pushd "$d"
        echo 0 > last_id
        jj desc -m "init jjq"
        jj squash
        popd
        jj workspace forget jjq
    fi
}

next_id() {
    exec 3>&1
    exec 1>>/tmp/jjq.log 2>/dev/null
    local d=$(mktemp -d)
    trap "rm -rf $d" EXIT
    local workspace_name="jjq$$"
    jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    pushd "$d"
    local curr="$(head -1 < last_id)"
    local id=$((curr + 1))
    echo "$id" > last_id
    jj desc -m "$curr -> $id" -m "pid: $$"
    jj bookmark set "$jjq_bookmark"
    jj workspace forget "$workspace_name"
    popd
    echo "$id" >&3
}

cmd_push() {
    exec 3>&1
    exec 1>>/tmp/jjq.log 2>&1

    # Revset of the candidate revision the user is pushing on to the merge queue
    local revset="$1"
    shift

    if ! jj log -r "$revset" --no-graph -T'change_id.short()++"\n"' >/dev/null 2>&1; then
        preferr "revset '$revset' not found"
        exit 1
    fi

    check_jjq

    local id="$(next_id)"
    local queue_bookmark="$(printf "jjq/queue/%06d" "$id")"

    jj bookmark create -r "$revset" "$queue_bookmark"
    prefout "revision '$revset' queued at $id" >&3
}

cmd_run() {
    #exec 3>&1
    #exec 1>>/tmp/jjq.log 2>&1

    local id="$(jj bookmark list -r 'bookmarks(jjq/queue/*)' -T'name ++"\n"' | cut -f3 -d'/' | sort -n | head -1)"
    if [ -z "$id" ]; then
        preferr "queue is empty"
        exit 0
    fi

    local runner_workspace=$(mktemp -d)
    local run_name="jjq/run/$id"
    local lock="jjq/lock/run"

    # We use jj bookmarks to take out a global run lock, since only one runner
    # can process the queue at a time. This lets us avoid trying a cross-platform
    # file locking mechanism and keep it contained to jj.
    if ! jj bookmark create -r "$jjq_bookmark" "$lock" >/dev/null 2>&1; then
        # TODO: try to get the lock holder's PID from metadata somehow
        preferr "queue runner lock already held"
        exit 1
    fi

    # TODO: record this PID as metadata for the run somehow

    # Create a workspace to attempt the merge, with a new commit for the
    # merge-to-be with two parents: the trunk and the candidate revision
    jj workspace add -r "bookmarks(exact:$TRUNK_BOOKMARK)" -r "bookmarks(exact:jjq/queue/$id)" --name "$run_name" "$runner_workspace"
    pushd "$runner_workspace"

    # Check for conflicts in the merge-to-be commit
    if [ -n "$(jj log -r "${run_name}@" --no-graph -T'if(conflict, "has conflict(s)")')" ]; then
        jj bookmark delete "jjq/queue/$id"
        jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        jj desc -m "Failed: merge $id (conflicts)"
        preferr "merge $id has conflicts, marked as failed"
        preferr "workspace remains: $runner_workspace"
        popd
        exit 1
    fi

    jj desc -m "WIP: attempting merge $id"

    if ! $CHECK_COMMAND; then
        jj bookmark delete "jjq/queue/$id"
        jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        jj desc -m "Failed: merge $id (check)"
        preferr "merge $id check failed"
        preferr "workspace remains: $runner_workspace"
        popd
        exit 1
    else
        jj bookmark delete "jjq/queue/$id"
        jj desc -m "Success: merge $id"
        jj bookmark move "$TRUNK_BOOKMARK"
        popd
        jj workspace forget "$run_name"
        rm -rf "$runner_workspace"
    fi
}

case "$cmd" in
    push) cmd_push "$@" ;;
    run) cmd_run "$@" ;;
    *) usage ;;
esac
