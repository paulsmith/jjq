#!/bin/bash
set -euo pipefail

# Defaults per spec - can be overridden via jjq config
DEFAULT_TRUNK_BOOKMARK="main"
DEFAULT_MAX_FAILURES=3

err() {
    echo "$*" >&2
}

preferr() {
    err "jjq: $*"
}

prefout() {
    echo "jjq: $*"
}

# Lock directory inside .jj (not tracked by jj)
JJQ_LOCK_DIR=""

# Find the jj repo root and set up lock directory
init_lock_dir() {
    local repo_root
    repo_root=$(jj root 2>/dev/null) || {
        preferr "not in a jj repository"
        exit 1
    }
    JJQ_LOCK_DIR="${repo_root}/.jj/jjq-locks"
    mkdir -p "$JJQ_LOCK_DIR"
}

# Acquire a named lock using mkdir atomicity
# Usage: acquire_lock <name>
# Returns 0 if lock acquired, 1 if already held
acquire_lock() {
    local name="$1"
    local lockdir="${JJQ_LOCK_DIR}/${name}"

    if mkdir "$lockdir" 2>/dev/null; then
        # Got the lock - record PID for stale detection
        echo $$ > "$lockdir/pid"
        return 0
    fi
    return 1
}

# Release a named lock
# Usage: release_lock <name>
release_lock() {
    local name="$1"
    local lockdir="${JJQ_LOCK_DIR}/${name}"
    rm -rf "$lockdir"
}

# Check if a lock is held (for status display)
# Usage: is_lock_held <name>
is_lock_held() {
    local name="$1"
    local lockdir="${JJQ_LOCK_DIR}/${name}"
    [ -d "$lockdir" ]
}

# Run a command quietly - only show output on failure
run_quiet() {
    local output
    local exit_code
    output=$("$@" 2>&1) && exit_code=0 || exit_code=$?
    if [ $exit_code -ne 0 ]; then
        err "$output"
    fi
    return $exit_code
}

# Log an operation to the jjq branch by editing/creating a commit
# Usage: log_op <revision> <summary> [trailer1] [trailer2] ...
# If revision is empty, creates a new commit on jjq branch
log_op() {
    local rev="$1"
    shift
    local summary="$1"
    shift

    # Build message with trailers
    local msg="$summary"
    if [ $# -gt 0 ]; then
        msg="$msg"$'\n'
        for trailer in "$@"; do
            msg="$msg"$'\n'"$trailer"
        done
    fi

    if [ -n "$rev" ]; then
        # Edit existing commit
        run_quiet jj desc -r "$rev" -m "$msg"
    else
        # Create new commit on jjq branch (no workspace needed)
        local change_id
        change_id=$(jj new --no-edit -r "$jjq_bookmark" 2>&1 | head -1 | cut -f4 -d' ')
        run_quiet jj desc -r "$change_id" -m "$msg"
        run_quiet jj bookmark set -r "$change_id" "$jjq_bookmark"
    fi
}

timestamp() {
    date -u +%Y-%m-%dT%H:%M:%SZ
}

# Read a config value from the jjq metadata branch
# Usage: get_config <key> <default>
get_config() {
    local key="$1"
    local default="$2"
    local value
    value=$(jj file show "config/$key" -r "$jjq_bookmark" 2>/dev/null) || true
    if [ -n "$value" ]; then
        echo "$value"
    else
        echo "$default"
    fi
}

# Write a config value to the jjq metadata branch
# Usage: set_config <key> <value>
set_config() {
    local key="$1"
    local value="$2"

    local d
    d=$(mktemp -d)
    trap "rm -rf $d" EXIT

    local workspace_name="jjq-config-$$"
    run_quiet jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    pushd "$d" >/dev/null

    mkdir -p config
    echo "$value" > "config/$key"
    run_quiet jj desc -m "config: set $key"
    run_quiet jj bookmark set "$jjq_bookmark"

    popd >/dev/null
    run_quiet jj workspace forget "$workspace_name"
    rm -rf "$d"
    trap - EXIT
}

# Get effective config values (with defaults)
get_trunk_bookmark() {
    get_config "trunk_bookmark" "$DEFAULT_TRUNK_BOOKMARK"
}

get_check_command() {
    get_config "check_command" ""
}

get_max_failures() {
    get_config "max_failures" "$DEFAULT_MAX_FAILURES"
}

# Validate and normalize a sequence ID from user input
# Returns the zero-padded ID on success, exits with error on failure
validate_seq_id() {
    local input="$1"

    # Check for empty input
    if [ -z "$input" ]; then
        preferr "invalid sequence ID: empty"
        return 1
    fi

    # Check for non-numeric characters (only digits allowed)
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        preferr "invalid sequence ID: '$input' (must be numeric)"
        return 1
    fi

    # Convert to integer (strips leading zeros)
    local id=$((10#$input))

    # Check range
    if [ "$id" -lt 1 ] || [ "$id" -gt 999999 ]; then
        preferr "invalid sequence ID: $id (must be 1-999999)"
        return 1
    fi

    # Return zero-padded form
    printf "%06d" "$id"
}

usage() {
    err "usage: jjq <cmd>"
    err ""
    err "commands:"
    err "   push <revset>           - push revision on merge queue"
    err "   run                     - try to merge next candidate on queue"
    err "   status                  - print the status of the queue"
    err "   retry <id> [revset]     - retry a failed merge"
    err "   delete <id>             - delete a queued or failed item"
    err "   config [key] [value]    - get/set configuration"
    exit 1
}

[ $# -gt 0 ] || usage

cmd="$1"
shift

jjq_bookmark="jjq/_/_"

# Initialize lock directory (must be in a jj repo)
init_lock_dir

# Pure check - returns 0 if initialized, 1 if not
# No side effects, safe to call anywhere
jjq_is_initialized() {
    [ -n "$(jj bookmark list -r "bookmarks(exact:${jjq_bookmark})" -T name 2>/dev/null)" ]
}

# Idempotent initialization - safe to call multiple times
# Creates jjq branch structure if missing
ensure_jjq() {
    jjq_is_initialized && return 0

    local change_id
    change_id="$(jj new --no-edit 'root()' 2>&1 | cut -f4 -d' ')"
    run_quiet jj bookmark create -r "$change_id" "$jjq_bookmark"

    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d now
    trap "rm -rf $d" EXIT
    run_quiet jj workspace add -r "$jjq_bookmark" --name jjq "$d"
    pushd "$d" >/dev/null
    echo 0 > last_id
    run_quiet jj desc -m "init jjq"
    run_quiet jj squash
    popd >/dev/null
    run_quiet jj workspace forget jjq
    rm -rf "$d"
    trap - EXIT

    # First-time setup prompt
    maybe_configure_log_filter
}

# Prompt user to configure jj log filter (first-time setup)
maybe_configure_log_filter() {
    [ -f .jj/repo/config.toml ] && return
    [ -n "${NON_INTERACTIVE-}" ] && return

    echo "Welcome to jjq"
    echo -n "Configure \`jj log\` to hide jjq metadata? "
    read -n1 -p '(y/N) ' -r answer
    echo
    if [[ $answer == [yY] ]]; then
        cat > .jj/repo/config.toml <<-EOF
			[revsets]
			log = '~ ::${jjq_bookmark}'
		EOF
    fi
}

next_id() {
    # Take the lock using mkdir atomicity
    if ! acquire_lock "id"; then
        preferr "could not acquire sequence ID lock (another process may be pushing)"
        return 1
    fi

    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d now
    trap "rm -rf $d; release_lock id" EXIT

    local workspace_name="jjq$$"
    run_quiet jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    pushd "$d" >/dev/null
    local curr
    curr="$(head -1 < last_id)"
    local id=$((curr + 1))
    echo "$id" > last_id
    run_quiet jj desc -m "$curr -> $id" -m "pid: $$"
    run_quiet jj bookmark set "$jjq_bookmark"
    run_quiet jj workspace forget "$workspace_name"
    popd >/dev/null

    # Release the lock explicitly (trap is backup)
    release_lock "id"
    trap - EXIT
    rm -rf "$d"

    echo "$id"
}

cmd_push() {
    # Revset of the candidate revision the user is pushing on to the merge queue
    local revset="$1"
    shift

    # Dereference the stable change ID from the revset
    local change_id
    change_id=$(jj log -r "$revset" --no-graph -T'change_id.short()' 2>/dev/null) || {
        preferr "revset '$revset' not found"
        exit 1
    }

    ensure_jjq

    local id
    id="$(next_id)"
    local queue_bookmark
    queue_bookmark="$(printf "jjq/queue/%06d" "$id")"

    run_quiet jj bookmark create -r "$revset" "$queue_bookmark"

    # Log the operation (edit the commit created by next_id)
    log_op "$jjq_bookmark" "push: queued $revset at $id" \
        "Operation: push" \
        "Sequence-Id: $id" \
        "Revset: $revset" \
        "Change-Id: $change_id" \
        "Timestamp: $(timestamp)"

    prefout "revision '$revset' queued at $id"
}

cmd_run() {
    local id
    id="$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' | grep -E '^jjq/queue/[0-9]{6}$' | cut -f3 -d'/' | sort -n | head -1)"
    if [ -z "$id" ]; then
        prefout "queue is empty"
        exit 0
    fi
    prefout "processing queue item $id"

    ensure_jjq

    # Get config values
    local trunk_bookmark check_command
    trunk_bookmark=$(get_trunk_bookmark)
    check_command=$(get_check_command)

    if [ -z "$check_command" ]; then
        preferr "check_command not configured (use 'jjq config check_command <cmd>')"
        exit 1
    fi

    # Record trunk commit ID to detect if it moves during run
    local trunk_commit_id
    trunk_commit_id=$(jj log -r "bookmarks(exact:$trunk_bookmark)" --no-graph -T'commit_id')

    local runner_workspace
    runner_workspace=$(mktemp -d)
    local run_name
    run_name=$(printf "jjq-run-%06d" "$((10#$id))")

    # Take the run lock using mkdir atomicity
    if ! acquire_lock "run"; then
        preferr "queue runner lock already held"
        exit 1
    fi

    # shellcheck disable=SC2064 # Intentional: capture vars now
    trap "release_lock run; rm -rf $runner_workspace" EXIT

    # Create a workspace to attempt the merge, with a new commit for the
    # merge-to-be with two parents: the trunk and the candidate revision
    run_quiet jj workspace add -r "bookmarks(exact:$trunk_bookmark)" -r "bookmarks(exact:jjq/queue/$id)" --name "$run_name" "$runner_workspace"
    pushd "$runner_workspace" >/dev/null

    # Check for conflicts in the merge-to-be commit
    if [ -n "$(jj log -r "${run_name}@" --no-graph -T'if(conflict, "has conflict(s)")')" ]; then
        run_quiet jj bookmark delete "jjq/queue/$id"
        run_quiet jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        run_quiet jj desc -m "Failed: merge $id (conflicts)"
        popd >/dev/null
        # Log the failure with workspace path for cleanup
        log_op "" "run: failed $id (conflicts)" \
            "Operation: run" \
            "Sequence-Id: $((10#$id))" \
            "Result: conflict" \
            "Workspace: $runner_workspace" \
            "Timestamp: $(timestamp)"
        preferr "merge $id has conflicts, marked as failed"
        preferr "workspace remains: $runner_workspace"
        # Keep workspace for debugging, but release lock
        trap - EXIT
        release_lock "run"
        exit 1
    fi

    run_quiet jj desc -m "WIP: attempting merge $id"

    # Run check command - quiet on success, show output on failure
    local check_output
    local check_exit
    check_output=$(eval "$check_command" 2>&1) && check_exit=0 || check_exit=$?
    if [ $check_exit -ne 0 ]; then
        err "$check_output"
        run_quiet jj bookmark delete "jjq/queue/$id"
        run_quiet jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        run_quiet jj desc -m "Failed: merge $id (check)"
        popd >/dev/null
        # Log the failure with workspace path for cleanup
        log_op "" "run: failed $id (check)" \
            "Operation: run" \
            "Sequence-Id: $((10#$id))" \
            "Result: check-failed" \
            "Check-Command: $check_command" \
            "Workspace: $runner_workspace" \
            "Timestamp: $(timestamp)"
        preferr "merge $id check failed"
        preferr "workspace remains: $runner_workspace"
        # Keep workspace for debugging, but release lock
        trap - EXIT
        release_lock "run"
        exit 1
    fi

    # Verify trunk hasn't moved during the run
    local current_trunk_commit_id
    current_trunk_commit_id=$(jj log -r "bookmarks(exact:$trunk_bookmark)" --no-graph -T'commit_id')
    if [ "$trunk_commit_id" != "$current_trunk_commit_id" ]; then
        popd >/dev/null
        # Clean up workspace (this isn't a failure to debug)
        run_quiet jj workspace forget "$run_name"
        rm -rf "$runner_workspace"
        # Release lock
        release_lock "run"
        trap - EXIT
        # Leave queue item in place for retry
        preferr "trunk bookmark moved during run; queue item left in place, re-run to retry"
        exit 1
    fi

    # Success path
    # Capture the merge commit's change ID before any modifications
    local merge_change_id
    merge_change_id=$(jj log -r '@' --no-graph -T'change_id.short()')

    run_quiet jj bookmark delete "jjq/queue/$id"
    run_quiet jj desc -m "Success: merge $id"
    run_quiet jj bookmark move "$trunk_bookmark"
    popd >/dev/null
    run_quiet jj workspace forget "$run_name"

    prefout "merged $id to $trunk_bookmark (now at $merge_change_id)"

    # Log the success
    log_op "" "run: success $id" \
        "Operation: run" \
        "Sequence-Id: $((10#$id))" \
        "Result: success" \
        "Check-Command: $check_command" \
        "Timestamp: $(timestamp)"

    # Explicit cleanup (trap is backup for unexpected exits)
    release_lock "run"
    trap - EXIT
    rm -rf "$runner_workspace"
}

cmd_status() {
    if ! jjq_is_initialized; then
        prefout "jjq not initialized (run 'jjq push <revset>' to start)"
        return
    fi

    local max_failures
    max_failures=$(get_max_failures)

    local queue_items
    queue_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/queue/[0-9]{6}$' | sort || true)

    local failed_items
    failed_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/failed/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/failed/[0-9]{6}$' | sort -r | head -"$max_failures" || true)

    # Check for active run
    if is_lock_held "run"; then
        prefout "Run in progress"
        echo
    fi

    if [ -z "$queue_items" ] && [ -z "$failed_items" ]; then
        prefout "queue is empty"
        return
    fi

    if [ -n "$queue_items" ]; then
        prefout "Queued:"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $((10#$id)): $info"
        done <<< "$queue_items"
    fi

    if [ -n "$failed_items" ]; then
        if [ -n "$queue_items" ]; then
            echo
        fi
        prefout "Failed (recent):"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $((10#$id)): $info"
        done <<< "$failed_items"
    fi
}

cmd_retry() {
    if [ $# -lt 1 ]; then
        preferr "usage: jjq retry <id> [revset]"
        exit 1
    fi

    local id="$1"
    shift
    local padded_id
    padded_id=$(validate_seq_id "$id") || exit 1
    local failed_bookmark="jjq/failed/$padded_id"

    # Check if the failed bookmark exists
    if [ -z "$(jj bookmark list -r "bookmarks(exact:$failed_bookmark)" -T name 2>/dev/null)" ]; then
        preferr "failed item $id not found"
        exit 1
    fi

    local candidate_revset
    if [ $# -gt 0 ]; then
        # User provided an explicit revset
        candidate_revset="$1"
        if ! jj log -r "$candidate_revset" --no-graph -T'change_id.short()' >/dev/null 2>&1; then
            preferr "revset '$candidate_revset' not found"
            exit 1
        fi
        prefout "retrying failed item $id using '$candidate_revset'"
    else
        # Find the original candidate: the parent of the failed merge that
        # is not an ancestor of trunk. This is more robust than relying on
        # parent ordering.
        local trunk_bookmark
        trunk_bookmark=$(get_trunk_bookmark)
        local original_candidate
        original_candidate=$(jj log -r "parents($failed_bookmark) ~ ::$trunk_bookmark" --no-graph -T'change_id.short()' 2>/dev/null | head -1)

        if [ -z "$original_candidate" ]; then
            preferr "could not find original candidate for failed item $id"
            exit 1
        fi

        candidate_revset="$original_candidate"
        prefout "retrying failed item $id using original candidate $original_candidate"
    fi

    # Push the candidate to the queue using next_id
    ensure_jjq

    local new_id
    new_id="$(next_id)"
    local queue_bookmark
    queue_bookmark="$(printf "jjq/queue/%06d" "$new_id")"

    run_quiet jj bookmark create -r "$candidate_revset" "$queue_bookmark"

    # Delete the failed bookmark only after queue entry exists
    run_quiet jj bookmark delete "$failed_bookmark"

    # Log the operation (edit the commit created by next_id)
    local change_id
    change_id=$(jj log -r "$candidate_revset" --no-graph -T'change_id.short()' 2>/dev/null) || true
    log_op "$jjq_bookmark" "retry: requeued $id as $new_id" \
        "Operation: retry" \
        "Original-Id: $id" \
        "Sequence-Id: $new_id" \
        "Revset: $candidate_revset" \
        "Change-Id: $change_id" \
        "Timestamp: $(timestamp)"

    prefout "revision queued at $new_id"
}

cmd_delete() {
    if [ $# -lt 1 ]; then
        preferr "usage: jjq delete <id>"
        exit 1
    fi

    ensure_jjq

    local id="$1"
    local padded_id
    padded_id=$(validate_seq_id "$id") || exit 1

    local queue_bookmark="jjq/queue/$padded_id"
    local failed_bookmark="jjq/failed/$padded_id"
    local item_type=""

    # Check queue first, then failed
    if [ -n "$(jj bookmark list -r "bookmarks(exact:$queue_bookmark)" -T name 2>/dev/null)" ]; then
        run_quiet jj bookmark delete "$queue_bookmark"
        item_type="queued"
        prefout "deleted queued item $id"
    elif [ -n "$(jj bookmark list -r "bookmarks(exact:$failed_bookmark)" -T name 2>/dev/null)" ]; then
        run_quiet jj bookmark delete "$failed_bookmark"
        item_type="failed"
        prefout "deleted failed item $id"
    else
        preferr "item $id not found in queue or failed"
        exit 1
    fi

    # Log the operation
    log_op "" "delete: removed $item_type item $id" \
        "Operation: delete" \
        "Sequence-Id: $id" \
        "Item-Type: $item_type" \
        "Timestamp: $(timestamp)"
}

cmd_config() {
    ensure_jjq

    if [ $# -eq 0 ]; then
        # Show all config
        local cc
        cc=$(get_check_command)
        echo "trunk_bookmark = $(get_trunk_bookmark)"
        echo "check_command = ${cc:-(not set)}"
        echo "max_failures = $(get_max_failures)"
        return
    fi

    local key="$1"
    shift

    # Validate key
    case "$key" in
        trunk_bookmark|check_command|max_failures) ;;
        *)
            preferr "unknown config key: $key"
            preferr "valid keys: trunk_bookmark, check_command, max_failures"
            exit 1
            ;;
    esac

    if [ $# -eq 0 ]; then
        # Get single value
        case "$key" in
            trunk_bookmark) get_trunk_bookmark ;;
            check_command) get_check_command ;;
            max_failures) get_max_failures ;;
        esac
    else
        # Set value
        local value="$1"

        # Validate value
        if [ "$key" = "max_failures" ]; then
            if ! [[ "$value" =~ ^[0-9]+$ ]]; then
                preferr "max_failures must be a number"
                exit 1
            fi
        fi

        set_config "$key" "$value"
        prefout "$key = $value"

        # Log the config change (edit existing commit, don't create new one)
        log_op "$jjq_bookmark" "config: set $key" \
            "Operation: config" \
            "Key: $key" \
            "Value: $value" \
            "Timestamp: $(timestamp)"
    fi
}

case "$cmd" in
    push) cmd_push "$@" ;;
    run) cmd_run "$@" ;;
    status) cmd_status "$@" ;;
    retry) cmd_retry "$@" ;;
    delete) cmd_delete "$@" ;;
    config) cmd_config "$@" ;;
    *) usage ;;
esac
