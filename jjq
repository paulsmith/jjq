#!/bin/bash
set -euo pipefail

TRUNK_BOOKMARK=main
CHECK_COMMAND="make"

err() {
    echo "$*" >&2
}

preferr() {
    err "jjq: $*"
}

prefout() {
    echo "jjq: $*"
}

# Run a command quietly - only show output on failure
run_quiet() {
    local output
    local exit_code
    output=$("$@" 2>&1) && exit_code=0 || exit_code=$?
    if [ $exit_code -ne 0 ]; then
        err "$output"
    fi
    return $exit_code
}

# Log an operation to the jjq branch by editing/creating a commit
# Usage: log_op <revision> <summary> [trailer1] [trailer2] ...
# If revision is empty, creates a new commit on jjq branch
log_op() {
    local rev="$1"
    shift
    local summary="$1"
    shift

    # Build message with trailers
    local msg="$summary"
    if [ $# -gt 0 ]; then
        msg="$msg"$'\n'
        for trailer in "$@"; do
            msg="$msg"$'\n'"$trailer"
        done
    fi

    if [ -n "$rev" ]; then
        # Edit existing commit
        run_quiet jj desc -r "$rev" -m "$msg"
    else
        # Create new commit on jjq branch (no workspace needed)
        local change_id
        change_id=$(jj new --no-edit -r "$jjq_bookmark" 2>&1 | head -1 | cut -f4 -d' ')
        run_quiet jj desc -r "$change_id" -m "$msg"
        run_quiet jj bookmark set -r "$change_id" "$jjq_bookmark"
    fi
}

timestamp() {
    date -u +%Y-%m-%dT%H:%M:%SZ
}

usage() {
    err "usage: jjq <cmd>"
    err ""
    err "commands:"
    err "   push <revset>           - push revision on merge queue"
    err "   run                     - try to merge next candidate on queue"
    err "   status                  - print the status of the queue"
    err "   retry <id> [revset]     - retry a failed merge"
    err "   delete <id>             - delete a queued item"
    exit 1
}

[ $# -gt 0 ] || usage

cmd="$1"
shift

jjq_bookmark="jjq/_/_"

check_jjq() {
    if [ -z "$(jj bookmark list -r "bookmarks(exact:${jjq_bookmark})" -T name)" ]; then
        local change_id
        change_id="$(jj new --no-edit 'root()' 2>&1 | cut -f4 -d' ')"
        run_quiet jj bookmark create -r "$change_id" "$jjq_bookmark"
        local d
        d=$(mktemp -d)
        # shellcheck disable=SC2064 # Intentional: capture $d now
        trap "rm -rf $d" EXIT
        run_quiet jj workspace add -r "$jjq_bookmark" --name jjq "$d"
        pushd "$d" >/dev/null
        echo 0 > last_id
        run_quiet jj desc -m "init jjq"
        run_quiet jj squash
        popd >/dev/null
        run_quiet jj workspace forget jjq

        if [ ! -f .jj/repo/config.toml ]; then
            if [ -z "${NON_INTERACTIVE-}" ]; then
                echo "Welcome to jjq"
                echo -n "Configure \`jj log\` to hide jjq metadata? "
                read -n1 -p '(y/N) ' -r answer
                echo
                if [[ $answer == [yY] ]]; then
                    cat > .jj/repo/config.toml <<-EOF
						[revsets]
						log = '~ ::${jjq_bookmark}'
					EOF
                fi
            fi
        fi
    fi
}

next_id() {
    local lock="jjq/lock/id"

    # Take the lock
    if ! jj bookmark create -r "$jjq_bookmark" "$lock" >/dev/null 2>&1; then
        preferr "could not acquire sequence ID lock (another process may be pushing)"
        return 1
    fi

    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d and $lock now
    trap "rm -rf $d; jj bookmark delete $lock >/dev/null 2>&1" EXIT

    local workspace_name="jjq$$"
    run_quiet jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    pushd "$d" >/dev/null
    local curr
    curr="$(head -1 < last_id)"
    local id=$((curr + 1))
    echo "$id" > last_id
    run_quiet jj desc -m "$curr -> $id" -m "pid: $$"
    run_quiet jj bookmark set "$jjq_bookmark"
    run_quiet jj workspace forget "$workspace_name"
    popd >/dev/null

    # Release the lock explicitly (trap is backup)
    jj bookmark delete "$lock" >/dev/null 2>&1
    trap - EXIT
    rm -rf "$d"

    echo "$id"
}

cmd_push() {
    # Revset of the candidate revision the user is pushing on to the merge queue
    local revset="$1"
    shift

    local change_id
    change_id=$(jj log -r "$revset" --no-graph -T'change_id.short()' 2>/dev/null) || {
        preferr "revset '$revset' not found"
        exit 1
    }

    check_jjq

    local id
    id="$(next_id)"
    local queue_bookmark
    queue_bookmark="$(printf "jjq/queue/%06d" "$id")"

    run_quiet jj bookmark create -r "$revset" "$queue_bookmark"

    # Log the operation (edit the commit created by next_id)
    log_op "$jjq_bookmark" "push: queued $revset at $id" \
        "Operation: push" \
        "Sequence-Id: $id" \
        "Revset: $revset" \
        "Change-Id: $change_id" \
        "Timestamp: $(timestamp)"

    prefout "revision '$revset' queued at $id"
}

cmd_run() {
    local id
    id="$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' | grep -E '^jjq/queue/[0-9]{6}$' | cut -f3 -d'/' | sort -n | head -1)"
    if [ -z "$id" ]; then
        preferr "queue is empty"
        exit 0
    fi
    prefout "processing queue item $id"

    check_jjq

    local runner_workspace
    runner_workspace=$(mktemp -d)
    local run_name="jjq/run/$id"
    local lock="jjq/lock/run"

    # We use jj bookmarks to take out a global run lock, since only one runner
    # can process the queue at a time. This lets us avoid trying a cross-platform
    # file locking mechanism and keep it contained to jj.
    if ! jj bookmark create -r "$jjq_bookmark" "$lock" >/dev/null 2>&1; then
        preferr "queue runner lock already held"
        exit 1
    fi

    # shellcheck disable=SC2064 # Intentional: capture vars now
    trap "jj bookmark delete $lock >/dev/null 2>&1; rm -rf $runner_workspace" EXIT

    # Create a workspace to attempt the merge, with a new commit for the
    # merge-to-be with two parents: the trunk and the candidate revision
    run_quiet jj workspace add -r "bookmarks(exact:$TRUNK_BOOKMARK)" -r "bookmarks(exact:jjq/queue/$id)" --name "$run_name" "$runner_workspace"
    pushd "$runner_workspace" >/dev/null

    # Check for conflicts in the merge-to-be commit
    if [ -n "$(jj log -r "${run_name}@" --no-graph -T'if(conflict, "has conflict(s)")')" ]; then
        run_quiet jj bookmark delete "jjq/queue/$id"
        run_quiet jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        run_quiet jj desc -m "Failed: merge $id (conflicts)"
        popd >/dev/null
        # Log the failure
        log_op "" "run: failed $id (conflicts)" \
            "Operation: run" \
            "Sequence-Id: $((10#$id))" \
            "Result: conflict" \
            "Timestamp: $(timestamp)"
        preferr "merge $id has conflicts, marked as failed"
        preferr "workspace remains: $runner_workspace"
        # Keep workspace for debugging, but release lock
        trap - EXIT
        jj bookmark delete "$lock" >/dev/null 2>&1
        exit 1
    fi

    run_quiet jj desc -m "WIP: attempting merge $id"

    # Run check command - quiet on success, show output on failure
    local check_output
    local check_exit
    check_output=$($CHECK_COMMAND 2>&1) && check_exit=0 || check_exit=$?
    if [ $check_exit -ne 0 ]; then
        err "$check_output"
        run_quiet jj bookmark delete "jjq/queue/$id"
        run_quiet jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        run_quiet jj desc -m "Failed: merge $id (check)"
        popd >/dev/null
        # Log the failure
        log_op "" "run: failed $id (check)" \
            "Operation: run" \
            "Sequence-Id: $((10#$id))" \
            "Result: check-failed" \
            "Check-Command: $CHECK_COMMAND" \
            "Timestamp: $(timestamp)"
        preferr "merge $id check failed"
        preferr "workspace remains: $runner_workspace"
        # Keep workspace for debugging, but release lock
        trap - EXIT
        jj bookmark delete "$lock" >/dev/null 2>&1
        exit 1
    fi

    # Success path
    run_quiet jj bookmark delete "jjq/queue/$id"
    run_quiet jj desc -m "Success: merge $id"
    run_quiet jj bookmark move "$TRUNK_BOOKMARK"
    popd >/dev/null
    run_quiet jj workspace forget "$run_name"

    # Log the success
    log_op "" "run: success $id" \
        "Operation: run" \
        "Sequence-Id: $((10#$id))" \
        "Result: success" \
        "Check-Command: $CHECK_COMMAND" \
        "Timestamp: $(timestamp)"

    # Explicit cleanup (trap is backup for unexpected exits)
    jj bookmark delete "$lock" >/dev/null 2>&1
    trap - EXIT
    rm -rf "$runner_workspace"
}

cmd_status() {
    local max_failures=3  # TODO: make configurable via jjq config

    # Check if jjq is initialized
    if [ -z "$(jj bookmark list -r "bookmarks(exact:${jjq_bookmark})" -T name 2>/dev/null)" ]; then
        prefout "jjq not initialized (push a revision on to the queue to initialize) "
        return
    fi

    local queue_items
    queue_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/queue/[0-9]{6}$' | sort || true)

    local failed_items
    failed_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/failed/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/failed/[0-9]{6}$' | sort -r | head -"$max_failures" || true)

    # Check for active run
    if jj bookmark list -r 'bookmarks(exact:"jjq/lock/run")' -T'name' 2>/dev/null | grep -q 'jjq/lock/run'; then
        prefout "Run in progress"
        echo
    fi

    if [ -z "$queue_items" ] && [ -z "$failed_items" ]; then
        prefout "queue is empty"
        return
    fi

    if [ -n "$queue_items" ]; then
        prefout "Queued:"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $((10#$id)): $info"
        done <<< "$queue_items"
    fi

    if [ -n "$failed_items" ]; then
        if [ -n "$queue_items" ]; then
            echo
        fi
        prefout "Failed (recent):"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $((10#$id)): $info"
        done <<< "$failed_items"
    fi
}

cmd_retry() {
    if [ $# -lt 1 ]; then
        preferr "usage: jjq retry <id> [revset]"
        exit 1
    fi

    local id="$1"
    shift
    local padded_id
    padded_id=$(printf "%06d" "$id")
    local failed_bookmark="jjq/failed/$padded_id"

    # Check if the failed bookmark exists
    if [ -z "$(jj bookmark list -r "bookmarks(exact:$failed_bookmark)" -T name 2>/dev/null)" ]; then
        preferr "failed item $id not found"
        exit 1
    fi

    local candidate_revset
    if [ $# -gt 0 ]; then
        # User provided an explicit revset
        candidate_revset="$1"
        if ! jj log -r "$candidate_revset" --no-graph -T'change_id.short()' >/dev/null 2>&1; then
            preferr "revset '$candidate_revset' not found"
            exit 1
        fi
        prefout "retrying failed item $id using '$candidate_revset'"
    else
        # Get the second parent (the original candidate) of the failed merge
        local original_candidate
        original_candidate=$(jj log -r "$failed_bookmark" --no-graph -T'parents.map(|p| p.change_id().short()).join(" ")' | cut -d' ' -f2)

        if [ -z "$original_candidate" ]; then
            preferr "could not find original candidate for failed item $id"
            exit 1
        fi

        # Find user bookmarks that were on the original candidate
        # (bookmarks that are not jjq-namespaced)
        local user_bookmarks
        user_bookmarks=$(jj log -r "$original_candidate" --no-graph -T'bookmarks' | tr ' ' '\n' | grep -v '^jjq/' | grep -v '^$' || true)

        if [ -n "$user_bookmarks" ]; then
            # Use the first user bookmark found
            local bookmark
            bookmark=$(echo "$user_bookmarks" | head -1)
            candidate_revset="bookmarks(exact:$bookmark)"
            prefout "retrying failed item $id using bookmark '$bookmark'"
        else
            # No user bookmark found, use the original candidate directly
            candidate_revset="$original_candidate"
            prefout "retrying failed item $id using original candidate $original_candidate"
        fi
    fi

    # Delete the failed bookmark
    run_quiet jj bookmark delete "$failed_bookmark"

    # Push the candidate to the queue using next_id
    check_jjq

    local new_id
    new_id="$(next_id)"
    local queue_bookmark
    queue_bookmark="$(printf "jjq/queue/%06d" "$new_id")"

    run_quiet jj bookmark create -r "$candidate_revset" "$queue_bookmark"

    # Log the operation (edit the commit created by next_id)
    local change_id
    change_id=$(jj log -r "$candidate_revset" --no-graph -T'change_id.short()' 2>/dev/null) || true
    log_op "$jjq_bookmark" "retry: requeued $id as $new_id" \
        "Operation: retry" \
        "Original-Id: $id" \
        "Sequence-Id: $new_id" \
        "Revset: $candidate_revset" \
        "Change-Id: $change_id" \
        "Timestamp: $(timestamp)"

    prefout "revision queued at $new_id"
}

cmd_delete() {
    if [ $# -lt 1 ]; then
        preferr "usage: jjq delete <id>"
        exit 1
    fi

    local id="$1"
    local padded_id
    padded_id=$(printf "%06d" "$id")

    local queue_bookmark="jjq/queue/$padded_id"
    local failed_bookmark="jjq/failed/$padded_id"
    local item_type=""

    # Check queue first, then failed
    if [ -n "$(jj bookmark list -r "bookmarks(exact:$queue_bookmark)" -T name 2>/dev/null)" ]; then
        run_quiet jj bookmark delete "$queue_bookmark"
        item_type="queued"
        prefout "deleted queued item $id"
    elif [ -n "$(jj bookmark list -r "bookmarks(exact:$failed_bookmark)" -T name 2>/dev/null)" ]; then
        run_quiet jj bookmark delete "$failed_bookmark"
        item_type="failed"
        prefout "deleted failed item $id"
    else
        preferr "item $id not found in queue or failed"
        exit 1
    fi

    # Log the operation
    log_op "" "delete: removed $item_type item $id" \
        "Operation: delete" \
        "Sequence-Id: $id" \
        "Item-Type: $item_type" \
        "Timestamp: $(timestamp)"
}

case "$cmd" in
    push) cmd_push "$@" ;;
    run) cmd_run "$@" ;;
    status) cmd_status "$@" ;;
    retry) cmd_retry "$@" ;;
    delete) cmd_delete "$@" ;;
    *) usage ;;
esac
