#!/bin/bash
set -euo pipefail

# Defaults per spec - can be overridden via jjq config
DEFAULT_TRUNK_BOOKMARK="main"
DEFAULT_MAX_FAILURES=3

# Exit codes
EXIT_SUCCESS=0
EXIT_CONFLICT=1
EXIT_CHECK_FAILED=2
EXIT_LOCK_HELD=3
EXIT_TRUNK_MOVED=4
EXIT_USAGE=10
# Internal sentinel (not returned to user)
_EXIT_QUEUE_EMPTY=99

err() {
    echo "$*" >&2
}

preferr() {
    err "jjq: $*"
}

prefout() {
    echo "jjq: $*"
}

# Lock directory inside .jj (not tracked by jj)
JJQ_LOCK_DIR=""

# Find the jj repo root and set up lock directory
init_lock_dir() {
    local repo_root
    repo_root=$(jj root 2>/dev/null) || {
        preferr "not in a jj repository"
        exit $EXIT_USAGE
    }
    JJQ_LOCK_DIR="${repo_root}/.jj/jjq-locks"
    mkdir -p "$JJQ_LOCK_DIR"
}

# Acquire a named lock using mkdir atomicity
# Usage: acquire_lock <name>
# Returns 0 if lock acquired, EXIT_LOCK_HELD if already held
acquire_lock() {
    local name="$1"
    local lockdir="${JJQ_LOCK_DIR}/${name}"

    if mkdir "$lockdir" 2>/dev/null; then
        # Got the lock - record PID for stale detection
        echo $$ > "$lockdir/pid"
        return 0
    fi
    return $EXIT_LOCK_HELD
}

# Release a named lock
# Usage: release_lock <name>
release_lock() {
    local name="$1"
    local lockdir="${JJQ_LOCK_DIR}/${name}"
    rm -rf "$lockdir"
}

# Check if a lock is held (for status display)
# Usage: is_lock_held <name>
is_lock_held() {
    local name="$1"
    local lockdir="${JJQ_LOCK_DIR}/${name}"
    [ -d "$lockdir" ]
}

# Run a command quietly - only show output on failure
run_quiet() {
    local output
    local exit_code
    output=$("$@" 2>&1) && exit_code=0 || exit_code=$?
    if [ $exit_code -ne 0 ]; then
        err "$output"
    fi
    return $exit_code
}

# Log an operation to the jjq branch by editing/creating a commit
# Usage: log_op <revision> <summary> [trailer1] [trailer2] ...
# If revision is empty, creates a new commit on jjq branch
log_op() {
    local rev="$1"
    shift
    local summary="$1"
    shift

    # Build message with trailers
    local msg="$summary"
    if [ $# -gt 0 ]; then
        msg="$msg"$'\n'
        for trailer in "$@"; do
            msg="$msg"$'\n'"$trailer"
        done
    fi

    if [ -n "$rev" ]; then
        # Edit existing commit
        run_quiet jj desc -r "$rev" -m "$msg"
    else
        # Create new commit on jjq branch (no workspace needed)
        local change_id
        change_id=$(jj new --no-edit -r "$jjq_bookmark" 2>&1 | head -1 | cut -f4 -d' ')
        run_quiet jj desc -r "$change_id" -m "$msg"
        run_quiet jj bookmark set -r "$change_id" "$jjq_bookmark"
    fi
}

timestamp() {
    date -u +%Y-%m-%dT%H:%M:%SZ
}

# Look up the filesystem path of a workspace from jjq metadata log history.
# Usage: lookup_workspace_path <unpadded_id>
lookup_workspace_path() {
    jj log -r "ancestors(bookmarks(exact:\"jjq/_/_\"), 100)" --no-graph \
        -T 'description ++ "\n---\n"' 2>/dev/null | \
        grep -A 10 "Sequence-Id: $1$" | \
        grep "^Workspace:" | head -1 | cut -d' ' -f2- || true
}

# Read a config value from the jjq metadata branch
# Usage: get_config <key> <default>
get_config() {
    local key="$1"
    local default="$2"
    local value
    value=$(jj file show "config/$key" -r "$jjq_bookmark" 2>/dev/null) || true
    if [ -n "$value" ]; then
        echo "$value"
    else
        echo "$default"
    fi
}

# Write a config value to the jjq metadata branch
# Usage: set_config <key> <value>
set_config() {
    local key="$1"
    local value="$2"

    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d now
    trap "rm -rf $d" EXIT

    local workspace_name="jjq-config-$$"
    run_quiet jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    pushd "$d" >/dev/null

    mkdir -p config
    echo "$value" > "config/$key"
    run_quiet jj desc -m "config: set $key"
    run_quiet jj bookmark set "$jjq_bookmark"

    popd >/dev/null
    run_quiet jj workspace forget "$workspace_name"
    rm -rf "$d"
    trap - EXIT
}

# Get effective config values (with defaults)
get_trunk_bookmark() {
    get_config "trunk_bookmark" "$DEFAULT_TRUNK_BOOKMARK"
}

get_check_command() {
    get_config "check_command" ""
}

get_max_failures() {
    get_config "max_failures" "$DEFAULT_MAX_FAILURES"
}

# Pre-flight conflict check: verify a revision merges cleanly with trunk.
# Usage: preflight_conflict_check <revset> <trunk_bookmark>
# Returns 0 if clean, 1 if conflicts (with error messages printed).
preflight_conflict_check() {
    local revset="$1"
    local trunk_bookmark="$2"

    # Verify trunk bookmark exists
    if ! jj log -r "bookmarks(exact:$trunk_bookmark)" --no-graph -T'""' >/dev/null 2>&1; then
        preferr "trunk bookmark '$trunk_bookmark' not found"
        return $EXIT_USAGE
    fi

    # Create temporary merge commit in-repo only, no working copy
    local conflict_check_change_id
    conflict_check_change_id=$(jj new --no-edit -r "$trunk_bookmark" -r "$revset" 2>&1 | head -1 | cut -f4 -d' ')

    # Check for conflicts
    local has_conflicts
    has_conflicts=$(jj log -r "$conflict_check_change_id" --no-graph -T'if(conflict, "yes")')

    jj abandon "$conflict_check_change_id" >/dev/null 2>&1

    if [ -n "$has_conflicts" ]; then
        preferr "revision '$revset' conflicts with $trunk_bookmark"
        preferr "rebase onto $trunk_bookmark and resolve conflicts before pushing"
        return $EXIT_CONFLICT
    fi
    return 0
}

# Validate and normalize a sequence ID from user input
# Returns the zero-padded ID on success, exits with error on failure
validate_seq_id() {
    local input="$1"

    # Check for empty input
    if [ -z "$input" ]; then
        preferr "invalid sequence ID: empty"
        return $EXIT_USAGE
    fi

    # Check for non-numeric characters (only digits allowed)
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        preferr "invalid sequence ID: '$input' (must be numeric)"
        return $EXIT_USAGE
    fi

    # Convert to integer (strips leading zeros)
    local id=$((10#$input))

    # Check range
    if [ "$id" -lt 1 ] || [ "$id" -gt 999999 ]; then
        preferr "invalid sequence ID: $id (must be 1-999999)"
        return $EXIT_USAGE
    fi

    # Return zero-padded form
    printf "%06d" "$id"
}

usage() {
    err "usage: jjq <cmd>"
    err ""
    err "commands:"
    err "   push <revset>           - push revision on merge queue"
    err "   run [--all]             - try to merge next candidate (or all) on queue"
    err "   status                  - print the status of the queue"
    err "   delete <id>             - delete a queued or failed item"
    err "   config [key] [value]    - get/set configuration"
    err "   clean                  - remove failed workspaces"
    exit $EXIT_USAGE
}

[ $# -gt 0 ] || usage

cmd="$1"
shift

jjq_bookmark="jjq/_/_"

# Initialize lock directory (must be in a jj repo)
init_lock_dir

# Pure check - returns 0 if initialized, 1 if not
# No side effects, safe to call anywhere
jjq_is_initialized() {
    [ -n "$(jj bookmark list -r "bookmarks(exact:${jjq_bookmark})" -T name 2>/dev/null)" ]
}

# Idempotent initialization - safe to call multiple times
# Creates jjq branch structure if missing
ensure_jjq() {
    jjq_is_initialized && return 0

    local change_id
    change_id="$(jj new --no-edit 'root()' 2>&1 | cut -f4 -d' ')"
    run_quiet jj bookmark create -r "$change_id" "$jjq_bookmark"

    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d now
    trap "rm -rf $d" EXIT
    run_quiet jj workspace add -r "$jjq_bookmark" --name jjq "$d"
    pushd "$d" >/dev/null
    echo 0 > last_id
    run_quiet jj desc -m "init jjq"
    run_quiet jj squash
    popd >/dev/null
    run_quiet jj workspace forget jjq
    rm -rf "$d"
    trap - EXIT

    # First-time setup hint
    maybe_show_log_hint
}

# Show one-time hint about configuring jj log filter
maybe_show_log_hint() {
    # Skip if not a terminal
    [ -t 1 ] || return 0

    # Skip if log filter already configured
    local current_log
    current_log=$(jj config get revsets.log 2>/dev/null) || true
    [[ "$current_log" == *"$jjq_bookmark"* ]] && return 0

    # Skip if hint already shown (check metadata)
    local hint_shown
    hint_shown=$(jj file show "log_hint_shown" -r "$jjq_bookmark" 2>/dev/null) || true
    [ -n "$hint_shown" ] && return 0

    # Show hint
    echo ""
    echo "hint: To hide jjq metadata from 'jj log', run:"
    echo "  jj config set --repo revsets.log '~ ::$jjq_bookmark'"
    echo ""

    # Record hint shown in metadata
    record_hint_shown
}

# Record that the log hint has been shown
record_hint_shown() {
    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d now
    trap "rm -rf $d" RETURN

    local workspace_name="jjq$$"
    run_quiet jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    echo "1" > "$d/log_hint_shown"
    run_quiet jj -R "$d" commit -m "record log hint shown"
    run_quiet jj -R "$d" squash
    run_quiet jj workspace forget "$workspace_name"
}

next_id() {
    # Take the lock using mkdir atomicity
    if ! acquire_lock "id"; then
        preferr "could not acquire sequence ID lock (another process may be pushing)"
        return $EXIT_LOCK_HELD
    fi

    local d
    d=$(mktemp -d)
    # shellcheck disable=SC2064 # Intentional: capture $d now
    trap "rm -rf $d; release_lock id" EXIT

    local workspace_name="jjq$$"
    run_quiet jj workspace add -r "$jjq_bookmark" --name "$workspace_name" "$d"
    pushd "$d" >/dev/null
    local curr
    curr="$(head -1 < last_id)"
    local id=$((curr + 1))
    echo "$id" > last_id
    run_quiet jj desc -m "$curr -> $id" -m "pid: $$"
    run_quiet jj bookmark set "$jjq_bookmark"
    run_quiet jj workspace forget "$workspace_name"
    popd >/dev/null

    # Release the lock explicitly (trap is backup)
    release_lock "id"
    trap - EXIT
    rm -rf "$d"

    echo "$id"
}

cmd_push() {
    # Revset of the candidate revision the user is pushing on to the merge queue
    local revset="$1"
    shift

    # Dereference the stable change ID and commit ID from the revset
    local change_id commit_id ids
    ids=$(jj log -r "$revset" --no-graph -T'change_id.short() ++ " " ++ commit_id' 2>/dev/null) || {
        preferr "revset '$revset' not found"
        exit $EXIT_USAGE
    }
    change_id="${ids%% *}"
    commit_id="${ids#* }"

    # Resolve trunk bookmark (needed for both idempotent cleanup and preflight)
    local trunk_bookmark
    trunk_bookmark=$(get_trunk_bookmark)

    # Idempotent push: clean up existing queue/failed entries for this change
    local bookmark entry_id entry_change_id entry_commit_id

    # Scan queue bookmarks
    for bookmark in $(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/queue/[0-9]{6}$' || true); do
        entry_commit_id=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'commit_id' 2>/dev/null) || continue
        if [ "$entry_commit_id" = "$commit_id" ]; then
            entry_id=$((10#${bookmark##*/}))
            preferr "revision already queued at $entry_id"
            exit $EXIT_USAGE
        fi
        entry_change_id=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short()' 2>/dev/null) || continue
        if [ "$entry_change_id" = "$change_id" ]; then
            entry_id=$((10#${bookmark##*/}))
            run_quiet jj bookmark delete "$bookmark"
            prefout "replacing queued entry $entry_id"
        fi
    done

    # Scan failed bookmarks: extract candidate change ID from jjq-candidate trailer
    for bookmark in $(jj bookmark list -r 'bookmarks(glob:"jjq/failed/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/failed/[0-9]{6}$' || true); do
        entry_change_id=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'description' 2>/dev/null | grep '^jjq-candidate: ' | head -1 | sed 's/^jjq-candidate: //') || continue
        if [ "$entry_change_id" = "$change_id" ]; then
            entry_id=$((10#${bookmark##*/}))
            run_quiet jj bookmark delete "$bookmark"
            prefout "clearing failed entry $entry_id"
        fi
    done

    # Pre-flight conflict check: verify revision could merge cleanly with trunk
    preflight_conflict_check "$revset" "$trunk_bookmark" || exit $?

    ensure_jjq

    local id
    id="$(next_id)"
    local queue_bookmark
    queue_bookmark="$(printf "jjq/queue/%06d" "$id")"

    run_quiet jj bookmark create -r "$revset" "$queue_bookmark"

    # Log the operation (edit the commit created by next_id)
    log_op "$jjq_bookmark" "push: queued $revset at $id" \
        "Operation: push" \
        "Sequence-Id: $id" \
        "Revset: $revset" \
        "Change-Id: $change_id" \
        "Timestamp: $(timestamp)"

    prefout "revision '$revset' queued at $id"
}

# Process one queue item. Returns:
#   EXIT_SUCCESS (0) = item merged
#   EXIT_CONFLICT (1) = merge conflicts
#   EXIT_CHECK_FAILED (2) = check command failed
#   EXIT_LOCK_HELD (3) = runner lock already held
#   EXIT_TRUNK_MOVED (4) = trunk bookmark moved during run
#   EXIT_USAGE (10) = check_command not configured
#   _EXIT_QUEUE_EMPTY (99) = queue empty
run_one_item() {
    local id
    id="$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' | grep -E '^jjq/queue/[0-9]{6}$' | cut -f3 -d'/' | sort -n | head -1 || true)"
    if [ -z "$id" ]; then
        prefout "queue is empty"
        return $_EXIT_QUEUE_EMPTY
    fi
    prefout "processing queue item $id"

    ensure_jjq

    # Get config values
    local trunk_bookmark check_command
    trunk_bookmark=$(get_trunk_bookmark)
    check_command=$(get_check_command)

    if [ -z "$check_command" ]; then
        preferr "check_command not configured (use 'jjq config check_command <cmd>')"
        return $EXIT_USAGE
    fi

    # Record trunk commit ID to detect if it moves during run
    local trunk_commit_id
    trunk_commit_id=$(jj log -r "bookmarks(exact:$trunk_bookmark)" --no-graph -T'commit_id')

    local runner_workspace
    runner_workspace=$(mktemp -d)
    local run_name
    run_name=$(printf "jjq-run-%06d" "$((10#$id))")

    # Take the run lock using mkdir atomicity
    if ! acquire_lock "run"; then
        preferr "queue runner lock already held"
        return $EXIT_LOCK_HELD
    fi

    # shellcheck disable=SC2064 # Intentional: capture vars now
    trap "release_lock run; rm -rf $runner_workspace" RETURN

    # Capture candidate's change ID before creating the merge workspace
    local candidate_change_id
    candidate_change_id=$(jj log -r "bookmarks(exact:jjq/queue/$id)" --no-graph -T'change_id.short()' 2>/dev/null)

    # Create a workspace to attempt the merge, with a new commit for the
    # merge-to-be with two parents: the trunk and the candidate revision
    run_quiet jj workspace add -r "bookmarks(exact:$trunk_bookmark)" -r "bookmarks(exact:jjq/queue/$id)" --name "$run_name" "$runner_workspace"
    pushd "$runner_workspace" >/dev/null

    # Check for conflicts in the merge-to-be commit
    if [ -n "$(jj log -r "${run_name}@" --no-graph -T'if(conflict, "has conflict(s)")')" ]; then
        run_quiet jj bookmark delete "jjq/queue/$id"
        run_quiet jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        run_quiet jj desc -m "Failed: merge $id (conflicts)"$'\n\n'"jjq-candidate: $candidate_change_id"
        popd >/dev/null
        # Log the failure with workspace path for cleanup
        log_op "" "run: failed $id (conflicts)" \
            "Operation: run" \
            "Sequence-Id: $((10#$id))" \
            "Result: conflict" \
            "Workspace: $runner_workspace" \
            "Timestamp: $(timestamp)"
        preferr "merge $id has conflicts, marked as failed"
        preferr "workspace: $runner_workspace"
        preferr ""
        preferr "To resolve:"
        preferr "  1. Rebase your revision onto $trunk_bookmark and resolve conflicts"
        preferr "  2. Run: jjq push <fixed-revset>"
        # Keep workspace for debugging, but release lock
        trap - RETURN
        release_lock "run"
        return $EXIT_CONFLICT
    fi

    run_quiet jj desc -m "WIP: attempting merge $id"

    # Run check command - quiet on success, show output on failure
    local check_output
    local check_exit
    check_output=$(eval "$check_command" 2>&1) && check_exit=0 || check_exit=$?
    if [ $check_exit -ne 0 ]; then
        err "$check_output"
        run_quiet jj bookmark delete "jjq/queue/$id"
        run_quiet jj bookmark create -r "${run_name}@" "jjq/failed/$id"
        run_quiet jj desc -m "Failed: merge $id (check)"$'\n\n'"jjq-candidate: $candidate_change_id"
        popd >/dev/null
        # Log the failure with workspace path for cleanup
        log_op "" "run: failed $id (check)" \
            "Operation: run" \
            "Sequence-Id: $((10#$id))" \
            "Result: check-failed" \
            "Check-Command: $check_command" \
            "Workspace: $runner_workspace" \
            "Timestamp: $(timestamp)"
        preferr "merge $id failed check, marked as failed"
        preferr "workspace: $runner_workspace"
        preferr ""
        preferr "To resolve:"
        preferr "  1. Fix the issue and create a new revision"
        preferr "  2. Run: jjq push <fixed-revset>"
        # Keep workspace for debugging, but release lock
        trap - RETURN
        release_lock "run"
        return $EXIT_CHECK_FAILED
    fi

    # Verify trunk hasn't moved during the run
    local current_trunk_commit_id
    current_trunk_commit_id=$(jj log -r "bookmarks(exact:$trunk_bookmark)" --no-graph -T'commit_id')
    if [ "$trunk_commit_id" != "$current_trunk_commit_id" ]; then
        popd >/dev/null
        # Clean up workspace (this isn't a failure to debug)
        run_quiet jj workspace forget "$run_name"
        rm -rf "$runner_workspace"
        # Release lock
        release_lock "run"
        trap - RETURN
        # Leave queue item in place for retry
        preferr "trunk bookmark moved during run; queue item left in place, re-run to retry"
        return $EXIT_TRUNK_MOVED
    fi

    # Success path
    # Capture the merge commit's change ID before any modifications
    local merge_change_id
    merge_change_id=$(jj log -r '@' --no-graph -T'change_id.short()')

    run_quiet jj bookmark delete "jjq/queue/$id"
    run_quiet jj desc -m "Success: merge $id"
    run_quiet jj bookmark move "$trunk_bookmark"
    popd >/dev/null
    run_quiet jj workspace forget "$run_name"

    prefout "merged $id to $trunk_bookmark (now at $merge_change_id)"

    # Log the success
    log_op "" "run: success $id" \
        "Operation: run" \
        "Sequence-Id: $((10#$id))" \
        "Result: success" \
        "Check-Command: $check_command" \
        "Timestamp: $(timestamp)"

    # Explicit cleanup (trap is backup for unexpected exits)
    release_lock "run"
    trap - RETURN
    rm -rf "$runner_workspace"
    return 0
}

cmd_run() {
    local run_all=false

    while [ $# -gt 0 ]; do
        case "$1" in
            --all)
                run_all=true
                shift
                ;;
            *)
                preferr "unknown option: $1"
                exit $EXIT_USAGE
                ;;
        esac
    done

    if [ "$run_all" = true ]; then
        local merged_count=0
        local failed_count=0
        local first_failure=""
        while true; do
            local result
            run_one_item && result=0 || result=$?
            if [ "$result" -eq $EXIT_SUCCESS ]; then
                merged_count=$((merged_count + 1))
            elif [ "$result" -eq $_EXIT_QUEUE_EMPTY ]; then
                break
            elif [ "$result" -eq $EXIT_LOCK_HELD ]; then
                # Can't process anything while another runner is active
                if [ $merged_count -gt 0 ] || [ $failed_count -gt 0 ]; then
                    prefout "processed $merged_count item(s), $failed_count failed (lock held, stopping)"
                fi
                exit $EXIT_LOCK_HELD
            else
                # Conflict or check failure - skip and continue
                failed_count=$((failed_count + 1))
                if [ -z "$first_failure" ]; then
                    first_failure=$result
                fi
            fi
        done

        local total=$((merged_count + failed_count))
        if [ $total -gt 0 ]; then
            if [ $failed_count -eq 0 ]; then
                prefout "processed $merged_count item(s)"
            else
                prefout "processed $merged_count item(s), $failed_count failed"
            fi
        fi

        if [ $failed_count -gt 0 ]; then
            exit "$first_failure"
        fi
        exit $EXIT_SUCCESS
    else
        # Process single item
        local result
        run_one_item && result=0 || result=$?
        if [ $result -eq $_EXIT_QUEUE_EMPTY ]; then
            exit 0  # Queue empty is success for single run
        fi
        exit $result
    fi
}

cmd_status() {
    if ! jjq_is_initialized; then
        prefout "jjq not initialized (run 'jjq push <revset>' to start)"
        return
    fi

    local max_failures
    max_failures=$(get_max_failures)

    local queue_items
    queue_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/queue/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/queue/[0-9]{6}$' | sort || true)

    local failed_items
    failed_items=$(jj bookmark list -r 'bookmarks(glob:"jjq/failed/??????")' -T'name ++"\n"' 2>/dev/null | grep -E '^jjq/failed/[0-9]{6}$' | sort -r | head -"$max_failures" || true)

    # Check for active run
    if is_lock_held "run"; then
        prefout "Run in progress"
        echo
    fi

    if [ -z "$queue_items" ] && [ -z "$failed_items" ]; then
        prefout "queue is empty"
        return
    fi

    if [ -n "$queue_items" ]; then
        prefout "Queued:"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local plain_id=$((10#$id))
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $plain_id: $info"
        done <<< "$queue_items"
    fi

    if [ -n "$failed_items" ]; then
        if [ -n "$queue_items" ]; then
            echo
        fi
        prefout "Failed (recent):"
        while IFS= read -r bookmark; do
            [ -n "$bookmark" ] || continue
            local id="${bookmark##*/}"
            local plain_id=$((10#$id))
            local info
            info=$(jj log -r "bookmarks(exact:$bookmark)" --no-graph -T'change_id.short() ++ " " ++ description.first_line()')
            echo "  $plain_id: $info"
        done <<< "$failed_items"
    fi
}

cmd_delete() {
    if [ $# -lt 1 ]; then
        preferr "usage: jjq delete <id>"
        exit $EXIT_USAGE
    fi

    ensure_jjq

    local id="$1"
    local padded_id
    padded_id=$(validate_seq_id "$id") || exit $EXIT_USAGE

    local queue_bookmark="jjq/queue/$padded_id"
    local failed_bookmark="jjq/failed/$padded_id"
    local item_type=""

    # Check queue first, then failed
    if [ -n "$(jj bookmark list -r "bookmarks(exact:$queue_bookmark)" -T name 2>/dev/null)" ]; then
        run_quiet jj bookmark delete "$queue_bookmark"
        item_type="queued"
        prefout "deleted queued item $id"
    elif [ -n "$(jj bookmark list -r "bookmarks(exact:$failed_bookmark)" -T name 2>/dev/null)" ]; then
        # Check for associated workspace before deleting
        local run_name="jjq-run-$padded_id"
        local workspace_path=""
        workspace_path=$(lookup_workspace_path "$((10#$padded_id))")

        run_quiet jj bookmark delete "$failed_bookmark"
        prefout "deleted failed item $id"

        # Always try to forget the workspace from jj (silently ignore if not found)
        jj workspace forget "$run_name" >/dev/null 2>&1 || true

        # Remove directory if it still exists
        if [ -n "$workspace_path" ] && [ -d "$workspace_path" ]; then
            rm -rf "$workspace_path"
            prefout "removed workspace $workspace_path"
        fi
        item_type="failed"
    else
        preferr "item $id not found in queue or failed"
        exit $EXIT_USAGE
    fi

    # Log the operation
    log_op "" "delete: removed $item_type item $id" \
        "Operation: delete" \
        "Sequence-Id: $id" \
        "Item-Type: $item_type" \
        "Timestamp: $(timestamp)"
}

cmd_config() {
    ensure_jjq

    if [ $# -eq 0 ]; then
        # Show all config
        local cc
        cc=$(get_check_command)
        echo "trunk_bookmark = $(get_trunk_bookmark)"
        echo "check_command = ${cc:-(not set)}"
        echo "max_failures = $(get_max_failures)"
        return
    fi

    local key="$1"
    shift

    # Validate key
    case "$key" in
        trunk_bookmark|check_command|max_failures) ;;
        *)
            preferr "unknown config key: $key"
            preferr "valid keys: trunk_bookmark, check_command, max_failures"
            exit $EXIT_USAGE
            ;;
    esac

    if [ $# -eq 0 ]; then
        # Get single value
        case "$key" in
            trunk_bookmark) get_trunk_bookmark ;;
            check_command) get_check_command ;;
            max_failures) get_max_failures ;;
        esac
    else
        # Set value
        local value="$1"

        # Validate value
        if [ "$key" = "max_failures" ]; then
            if ! [[ "$value" =~ ^[0-9]+$ ]]; then
                preferr "max_failures must be a number"
                exit $EXIT_USAGE
            fi
        fi

        set_config "$key" "$value"
        prefout "$key = $value"

        # Log the config change (edit existing commit, don't create new one)
        log_op "$jjq_bookmark" "config: set $key" \
            "Operation: config" \
            "Key: $key" \
            "Value: $value" \
            "Timestamp: $(timestamp)"
    fi
}

cmd_clean() {
    local removed=0
    local details=""

    # Find all jjq-run-* workspaces (extract just the workspace name)
    local workspaces
    workspaces=$(jj workspace list 2>/dev/null | awk '/^jjq-run-/{print $1}' | tr -d ':' || true)

    if [ -z "$workspaces" ]; then
        prefout "no workspaces to clean"
        return
    fi

    while IFS= read -r ws_name; do
        [ -n "$ws_name" ] || continue

        # Extract ID from workspace name (jjq-run-NNNNNN)
        local ws_id="${ws_name#jjq-run-}"
        local plain_id=$((10#$ws_id))

        # Check if corresponding failed bookmark exists
        local label
        if jj bookmark list -r "bookmarks(exact:jjq/failed/$ws_id)" -T name 2>/dev/null | grep -q .; then
            label="failed item $plain_id"
        else
            label="orphaned"
        fi

        # Try to find workspace filesystem path from log history
        local ws_path=""
        ws_path=$(lookup_workspace_path "$plain_id")

        # Forget the workspace from jj
        jj workspace forget "$ws_name" >/dev/null 2>&1 || true

        # Remove directory if found and still exists
        if [ -n "$ws_path" ] && [ -d "$ws_path" ]; then
            rm -rf "$ws_path"
        fi

        local path_info=""
        if [ -n "$ws_path" ]; then
            path_info=" $ws_path"
        fi
        details="$details"$'\n'"  $ws_name ($label)$path_info"
        removed=$((removed + 1))
    done <<< "$workspaces"

    if [ $removed -gt 0 ]; then
        prefout "removed $removed workspace(s)$details"
    fi
}

case "$cmd" in
    push) cmd_push "$@" ;;
    run) cmd_run "$@" ;;
    status) cmd_status "$@" ;;
    delete) cmd_delete "$@" ;;
    config) cmd_config "$@" ;;
    clean) cmd_clean "$@" ;;
    *) usage ;;
esac
